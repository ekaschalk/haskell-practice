#+TITLE: Learning Haskell
* Links
1. https://en.wikibooks.org/wiki/Haskell
2. https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang/haskell
3. http://dev.stephendiehl.com/hask/

* Spacemacs
** Lookup (, h)
- f :: helm-hoogle lookup
- h :: hoogle lookup
- t :: type at point

* Syntax
bi-nary functions can use infix notation.
Can be called with prefix by wrapping parenthesis the function.

function :: type(arg1) -> type(arg2) -> ... -> type(return)
(+) :: Int -> Int -> Int
function :: (typeclass typevar) => type(arg1) -> ... -> type(return)
(+) :: (Num a) => a -> a -> a

Example of higher-order function:
filter :: (a -> Bool) -> [a] -> [a]

Patten matching can take constructors

#+begin_src haskell
-- Binary functions as prefix and infix
(==) ((+) 1 2) (1 + 2)
map (^ 2) [1..3]
--
data Foo = Bar | Baz Int
f :: Foo -> Int
f Bar = 1
f (Baz x) = x+1
#+end_src

* Operators
- ==, +, - :: Basic ops.
- | :: Guards or conditions.
- ++ :: Concatenation.
- : :: Cons.
- . :: Composition.
- , :: Tuple constructor. Can't use as infix. (,) or (,,) or (,,,) or ...
- x@pattern :: Bind x the whole value matched by pattern. `list@(x:xs)`
- $ :: Application operator `zipWith ($) fs xs` or `f $ g $ x == f(g(x))`
- >>= :: Sequentially compose actions (See Monads)
- <$> :: Infix operator synonym for `Data.Functor.apply fmap` (See Applicatives)

#+begin_src haskell
-- Guards
absolute x
  | x < 0 = 0 - x
  | otherwise = x

-- This works, how are nullary functions parsed?
double = (*) 2
double 3 == 6
-- https://wiki.haskell.org/Constant_applicative_form
-- eta conversion: \x -> abs x == abs
-- point-free style is the name
-- ab x y = (+) x y
ab = (+)
ab 1 2
#+end_src

* Keywords
- where :: Function-local variables.
- let .. in :: Variables local to in-block (not needed in do-blocks).
- otherwise :: Alias for True used in guards.
- go :: Auxiliary func, accumulating param that takes extra argument 'res'.

#+begin_src haskell
-- Where within scope of all guards
numOfRealSolutions a b c
  | disc > 0  = 2
  | disc == 0 = 1
  | otherwise = 0
    where
    disc = b^2 - 4*a*c
#+end_src

* Types
Type names must be capitalized.
Type variables (polymorphic) are lower-case (like 'a').
=data= for defining new data types (algebraic).
=type= for type aliases
=newtype= new data types equivalent to existing ones

- Bool :: True, False.
- Char :: Single character.
- String :: Alias for [Char].
- List :: Same type container.
- Tuple :: Fixed number of elements, immutable, can have different types.

#+begin_src haskell
data Anniversary = Birthday String Int Int Int       -- name, year, month, day
                 | Wedding String String Int Int Int -- spouse name 1, spouse name 2, year, month, day

-- Birthday, Wedding are constructors
johnSmith :: Anniversary
johnSmith = Birthday "John Smith" 1968 7 3
#+end_src

* Functions
- 2-tuples
  - fst :: First element.
  - snd :: Second element.
- List
  - head :: First element (Don't use - throws error on empty list)
  - tail :: Second element ("")
- Num
  - Int, Integer, Double
  - negate :: Additive number inverse.
  - fromIntegral :: (Integral a, Num b) => a -> b (eg. Int/Integer)
- Eq
  - Objects that can be compared for equality.
- Foldable
  - length :: (Foldable t) => t a -> Int (more general than [a] -> Int)
- IO

foldr == reduce from right to left
scan == accumulate
foldr1, scanr1 -> last element is initializer
(Look at using Data.Foldable.fold instead)
